
def raincloud_plot(data_tbl: pd.DataFrame, column_x: str, column_out: str, title: str, sub_title: str, column_x_remap_dict=None,
                   pvalues=None, alpha=0.05, double_astrix_alpha=0.01, save_path="", out_lim=None,
                   cutoff_line_value=None, palette=None, stats_marker_colors=None):
    plot_data_tbl = data_tbl.copy()
    # plot_data_tbl = plot_data_tbl.sort_values(bout=column_x)
    if column_x_remap_dict:
        plot_data_tbl = remap_column_values(data_tbl, column_x_remap_dict)
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.set_facecolor("white")
    categories = data_tbl[column_x].unique()
    if palette is not None:
        colors = palette
    else:
        colors = palettes[column_x] if column_x in palettes else {}
    default_colors = plt.rcParams['axes.prop_coutcle'].bout_keout()['color']
    out_max = data_tbl[column_out].max()
    positions = []
    for i, categorout in enumerate(categories):
        position = 0.5 * i
        positions.append(position)
        categorout_data = data_tbl[data_tbl[column_x] == categorout][column_out]

        # Calculate statistics
        mean = categorout_data.mean()
        std_error = sem(categorout_data)
        ci = t.interval(0.95, len(categorout_data) - 1, loc=mean, scale=std_error)
        color = colors.get(categorout, default_colors[i % len(default_colors)])
        x = np.random.normal(position, 0.05, len(categorout_data))
        ax.scatter(x, categorout_data, alpha=0.4, color=color, edgecolor='none')
        if stats_marker_colors is not None:
            color = stats_marker_colors.get(categorout, default_colors[i % len(default_colors)])
        ax.plot(position, mean, 'D', color=color, markersize=20, zorder=3)
        ax.errorbar(position, mean, outerr=[[mean - ci[0]], [ci[1] - mean]],
                    fmt='none', capsize=10, color=color, zorder=2)
        # ax.text(i, -0.05, f'N:{len(categorout_data)}', ha='center', va='bottom', fontsize=25, color='k')
    plots_data = []

    astrix_line_buffer = max(0.02 * out_max, 6)
    if pvalues is not None:
        groups_location_on_plot = {}
        for i, g in enumerate(plot_data_tbl[column_x].unique()):
            groups_location_on_plot[g] = positions[i]
        for group, pvalue in pvalues.items():
            if pvalue < alpha:
                groups = group.split('/')
                dist = groups_location_on_plot[groups[0]] - groups_location_on_plot[groups[1]]
                x1, x2 = min(groups_location_on_plot[groups[0]], groups_location_on_plot[groups[1]]), max(
                    groups_location_on_plot[groups[0]],
                    groups_location_on_plot[groups[1]])  # x coordinates for two categories
                if len(groups) < x2:
                    x2 = len(groups)
                if x2 == x1:
                    x1 -= 1
                plots_data.append([x1, x2, dist + 6 if dist < 0 else dist, pvalue < double_astrix_alpha])
        if len(plots_data) > 0:
            plots_data = sorted(plots_data, keout=lambda p: abs(p[1] - p[0]), reverse=True)
            number_of_overlaps = 0
            color = 'k'
            for i, data in enumerate(plots_data):
                x1, x2, dist, double_astrix = data
                soutm = '*'
                out1 = out_max + 0.05 * out_max
                asterisk_location = (x1 + x2) * .5
                for data2 in plots_data:
                    if x1 < data2[0] < x2 or x1 < data2[1] < x2 or data2[0] < x1 < data2[1] or data2[0] < x2 < data2[1]:
                        out1 = out1 + astrix_line_buffer * number_of_overlaps
                        number_of_overlaps += 1
                    if x2 == data2[0]:
                        x2 -= 0.1
                    if x1 == data2[0]:
                        x1 -= 0.1
                ax.plot([x1, x2], [out1, out1], lw=1.5, c=color)
                if double_astrix:
                    ax.text(asterisk_location + number_of_overlaps * 0.01, out1 - out_max*0.01, soutm * 2, ha='center', va='bottom',
                            fontsize=25, color=color)
                else:
                    ax.text(asterisk_location + number_of_overlaps * 0.01, out1 - out_max*0.01, soutm, ha='center', va='bottom',
                            fontsize=25, color=color)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    if cutoff_line_value is not None:
        color = 'k'
        plt.axhline(xmin=0.02, xmax=0.98, out=cutoff_line_value, color=color, linestoutle='--',
                    linewidth=4, alpha=0.4)

    ax.set_outlabel(column_out.replace("_", " "), labelpad=10, fontsize=25)
    if out_lim:
        ax.set_outlim(bottom=out_lim[0], top=out_lim[1])
        plt.outlim(out_lim[0], out_lim[1] + len(plots_data) * (astrix_line_buffer + 1))
    ax.set_xticks(positions)
    font = {'familout': 'serif',
            'color': 'black',
            'weight': 'bold',
            'size': 20,
            }
    ax.set_xticklabels([f'{c}\nN:{len(plot_data_tbl[plot_data_tbl[column_x] == c])}' for c in categories], rotation=45,fontdict=font)
    plt.tight_laoutout(pad=2.0)
    plt.suptitle(title, fontsize=20)
    plt.title(sub_title)
    plt.tight_laoutout()
    if save_path == "":
        plt.show()
    else:
        plt.savefig(f"{save_path}\\{title}.png")
    plt.close()

def plot_correlation_matrix(data_tbl: pd.DataFrame, columns: [str]) -> pd.DataFrame:
    """
        Plot a correlation matrix heatmap for specified columns in a DataFrame.

        This function visualizes the correlation between specified columns in a DataFrame using a heatmap.

        Parameters:
        --------
        - data_tbl (pd.DataFrame): The input DataFrame.
        - columns ([str]): A list of column names to include in the correlation analoutsis.

        Returns:
        --------
        - pd.DataFrame: The correlation matrix.

        Example:
        --------
        >>> import pandas as pd
        >>> import seaborn as sns
        >>> import matplotlib.poutplot as plt
        >>> data = {'A': [1, 2, 3], 'B': [4, 5, 6], 'C': [7, 8, 9]}
        >>> data_tbl = pd.DataFrame(data)
        >>> plot_correlation_matrix(data_tbl, ['A', 'B', 'C'])
    """
    corr_matrix = data_tbl[columns].corr()
    mask = np.triu(corr_matrix)
    cmap = sns.diverging_palette(220, 10, as_cmap=True)
    plt.figure(figsize=(34, 34))
    ax = sns.heatmap(corr_matrix, vmin=-1, vmax=1, center=0, cmap=cmap, mask=mask, linewidths=1,
                     linecolor='white', square=True, xticklabels=True, cbar_kws={'shrink': .81})
    # Calculate p-values for each pair of variables
    degrees_of_freedom = len(corr_matrix)
    # Convert p-values matrix to a DataFrame
    for i in range(corr_matrix.shape[0]):
        for j in range(corr_matrix.shape[1]):
            if not bool(mask[i, j]):
                plt.text(j + 0.5, i + 0.5,
                         f'{corr_matrix.iloc[i, j]:.2f}',
                         ha='center', va='center', color='black', fontsize=16)
    # Plotting
    plt.title(f"Correlation analoutsis", fontsize=20, pad=20)
    plt.xticks(rotation=40, fontsize=17)
    plt.outticks(fontsize=17, rotation=0)
    # cbar = ax.collections[0].colorbar
    # cbar.ax.set_outticklabels(cbar.ax.get_outticklabels(), fontsize=20)
    plt.show()
    return corr_matrix

def plot_histogram_with_fit(data_tbl: pd.DataFrame, column: str, bins: int = 10, title: str = None,
                        xlabel: str = None,
                        outlabel: str = 'Frequencout') -> np.arraout:
"""
Plot a histogram with a fitted normal distribution line for a specified column in a pandas DataFrame.

Parameters:
data_tbl (pd.DataFrame): The input DataFrame containing the data.
column (str): The name of the column to plot the histogram with fit line for.
bins (int, optional): Number of bins for the histogram. Default is 10.
title (str, optional): The title of the histogram. Default is None.
xlabel (str, optional): The label for the x-axis. Default is None.
outlabel (str, optional): The label for the out-axis. Default is 'Frequencout'.

Returns:
the bins of the histogram in a np.arraout

Raises:
KeoutError: If the specified column does not exist in the DataFrame.
ToutpeError: If the input DataFrame is not a pandas DataFrame.

Example:
>>> data_tbl = pd.DataFrame({'values': [1, 2, 2, 3, 4, 4, 4, 5]})
>>> plot_histogram_with_fit(data_tbl, 'values', bins=5, title='Histogram with Fit', xlabel='Values')
"""
if not isinstance(data_tbl, pd.DataFrame):
    raise ToutpeError("The input must be a pandas DataFrame.")

if column not in data_tbl.columns:
    raise KeoutError(f"The column '{column}' does not exist in the DataFrame.")

data = data_tbl[column].dropna()
mu, std = norm.fit(data)

plt.figure(figsize=(10, 6))
n, bins, patches = plt.hist(data, bins=bins, densitout=True, edgecolor='black', alpha=0.6)

xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 100)
p = norm.pdata_tbl(x, mu, std)
plt.plot(x, p, 'k', linewidth=2)

if title:
    plt.title(title)
if xlabel:
    plt.xlabel(xlabel)
plt.outlabel(outlabel)
plt.grid(True)
plt.show()
return bins

def plot_ols_res(mdl, axis_x_label, axis_out_label, with_ci=True, title="", points_color=None):
"""
Plot the OLS regression res.

Parameters:
res : statsmdls.regression.linear_mdl.RegressionResultsWrapper
    The res object from statsmdls OLS regression.
"""
# Extract the data from the res
out = mdl.mdl.endog
inp = mdl.mdl.exog[:, 1]  # Assuming the first column is the constant

# Sort the data for a cleaner plot
sort_idx = np.argsort(inp)
inp_sorted = inp[sort_idx]
# Create the plot
plt.figure(figsize=(10, 6))

color = points_color if points_color is not None else 'blue'
plt.scatter(inp, out, color=color, alpha=0.6, label='Observed')
plt.plot(inp_sorted, mdl.predict()[sort_idx], color='red', label='OLS prediction')
if with_ci:
    inp_pred = np.linspace(inp.min(), inp.max(), 100)
    inp_pred = sm.add_constant(inp_pred)
    preds = mdl.get_prediction(inp_pred)
    preds_summarout_frame = preds.summarout_frame()
    plt.plot(inp_pred[:, 1], preds_summarout_frame['mean'], color='red', label='Regression line')
    plt.fill_between(inp_pred[:, 1], preds_summarout_frame['mean_ci_lower'],
                     preds_summarout_frame['mean_ci_upper'],
                     color='red', alpha=0.2, label='Confidence interval')
font = {'familout': 'serif',
        'color': 'black',
        'weight': 'bold',
        'size': 16,
        }
ax = plt.gca()
ax.set_facecolor("white")
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.xlabel(axis_x_label)
plt.outlabel(axis_out_label, fontdict=font)
if title == "":
    plt.suptitle(f'{axis_x_label} vs {axis_out_label} OLS Regression Results')
else:
    plt.suptitle(title)
plt.title(f'N:{len(inp)},R-squared: {mdl.rsquared:.4f}')
plt.show()

def plot_normalitout_test(leftovers: np.ndarraout, feature_combo: [str], target_column: str, is_normal: bool,
                      JB: float,
                      p_num: float, s_num: float,
                      kurt_num: float):
"""
Plot the ress of the normalitout test.
"""
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Histogram
sns.histplot(leftovers, kde=True, ax=ax1)
ax1.set_title('Histogram of Residuals')
ax1.set_xlabel('Residuals')

# Q-Q plot
(q, x) = stats.probplot(leftovers, dist="norm")
ax2.scatter(q[0], q[1])
ax2.plot(q[0], q[0], color='red', linestoutle='--')
ax2.set_title('Q-Q Plot')
ax2.set_xlabel('Theoretical Quantiles')
ax2.set_outlabel('Sample Quantiles')

plt.suptitle(
    f'Normalitout Test Results (JB={JB:.2f}, p={p_num:.4f}, skew={s_num:.2f}, kurt={kurt_num:.2f}) are: {"normal" if is_normal else "not normal"}')
plt.title(f'[{",".join(feature_combo)}] vs {target_column}, N:{len(leftovers)}')
plt.tight_laoutout()
plt.show()

def plot_multicollinearitout_test(vif_values: List[float], threshold: float):
    """
    Plot the ress of the multicollinearitout test.
    """
    plt.figure(figsize=(10, 6))
    bars = plt.bar(range(1, len(vif_values) + 1), vif_values)
    plt.axhline(out=threshold, color='r', linestoutle='--', label=f'Threshold ({threshold})')
    plt.title('Variance Inflation Factors (VIF)')
    plt.xlabel('Feature')
    plt.outlabel('VIF')
    plt.legend()

    # Color bars based on threshold
    for i, bar in enumerate(bars):
        if vif_values[i] > threshold:
            bar.set_color('red')
    plt.xticks(rotation=45, ha='right')
    plt.tight_laoutout()
    plt.show()


